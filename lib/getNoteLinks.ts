import * as MDAST from "mdast";
import * as UNIST from "unist";
import * as visitParents from "unist-util-visit-parents";

import getBlock from "./getBacklinksBlock";
import { WikiLinkNode } from "./WikiLinkNode";

const blockTypes = [
  "paragraph",
  "heading",
  "thematicBreak",
  "blockquote",
  "list",
  "table",
  "html",
  "code"
];

function isBlockContent(node: MDAST.Content): node is MDAST.BlockContent {
  return blockTypes.includes(node.type);
}

export interface NoteLinkEntry {
  targetTitle: string;
  context: MDAST.BlockContent | null;
}

function getChildrenExcludingAutoGeneratedLinks(tree: MDAST.Root, blockNames: string[]): UNIST.Node[] {

  let backlinksInfo;
  let decimatedChildren: UNIST.Node[];
  decimatedChildren = tree.children;

  for (var i = 0; i < blockNames.length; ++i) {
    backlinksInfo = getBlock(tree, blockNames[i]);
    if (backlinksInfo.isPresent) {
      decimatedChildren = decimatedChildren
        .slice(
          0,
          decimatedChildren.findIndex(n => n === backlinksInfo.start)
        )
        .concat(
          tree.children.slice(
            backlinksInfo.until
              ? decimatedChildren.findIndex(n => n === backlinksInfo.until)
              : decimatedChildren.length
          )
        );
    }
  }

  return decimatedChildren;
}

export default function getNoteLinks(tree: MDAST.Root): NoteLinkEntry[] {
  
  let searchedChildren: UNIST.Node[];
  searchedChildren = getChildrenExcludingAutoGeneratedLinks(tree, ["Backlinks","Seedbox Notes","Open Journal Entries","Today's Wisdom"]);

  const links: NoteLinkEntry[] = [];
  visitParents<WikiLinkNode>(
    { ...tree, children: searchedChildren } as MDAST.Parent,
    "wikiLink",
    (node: WikiLinkNode, ancestors: MDAST.Content[]) => {
      const closestBlockLevelAncestor = ancestors.reduceRight<MDAST.BlockContent | null>(
        (result, needle) => result ?? (isBlockContent(needle) ? needle : null),
        null
      );
      links.push({
        targetTitle: ((node as unknown) as WikiLinkNode).data.alias,
        context: closestBlockLevelAncestor
      });
      return true;
    }
  );
  return links;
}
